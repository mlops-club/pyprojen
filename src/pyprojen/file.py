import os
import shutil
from abc import (
    ABC,
    abstractmethod,
)
from typing import (
    Any,
    Dict,
    Optional,
)

from pyprojen.component import Component
from pyprojen.util import (
    is_writable,
    normalize_persisted_path,
    try_read_file_sync,
    write_file,
)
from pyprojen.util.constructs import find_closest_project


class FileBase(Component, ABC):
    """
    Base class for files in the project.
    """

    def __init__(
        self,
        scope: Component,
        file_path: str,
        committed: bool = True,
        edit_gitignore: Optional[bool] = None,
        readonly: bool = True,
        executable: bool = False,
        marker: Optional[bool] = None,
    ):
        """
        Initialize a FileBase.

        :param scope: The scope in which to define this file
        :param file_path: The file path
        :param committed: Whether the file should be committed
        :param edit_gitignore: Whether to edit .gitignore
        :param readonly: Whether the file should be readonly
        :param executable: Whether the file should be executable
        :param marker: Whether to add a marker to the file
        """
        project = find_closest_project(scope)
        root = project.root
        normalized_path = os.path.normpath(file_path)
        project_path = normalize_persisted_path(normalized_path)
        absolute_path = os.path.abspath(os.path.join(project.outdir, project_path))
        relative_project_path = os.path.relpath(absolute_path, root.outdir)
        root_project_path = normalize_persisted_path(relative_project_path)
        auto_id = f"{self.__class__.__name__}@{project_path}"

        if root.try_find_file(absolute_path) or scope.node.try_find_child(auto_id):
            raise ValueError(f"There is already a file under {root_project_path}")

        super().__init__(scope, auto_id)
        self.node.add_metadata("type", "file")
        self.node.add_metadata("path", root_project_path)

        self.readonly = not project.ejected and readonly  # Use the ejected property
        self.executable = executable
        self.path = project_path
        self.absolute_path = absolute_path
        self._should_add_marker = marker if marker is not None else True

        glob_pattern = self.path
        committed = (
            committed
            if committed is not None
            else (project.commit_generated if project.commit_generated is not None else True)
        )
        if committed and file_path != ".gitattributes":
            project.annotate_generated(file_path)

        if edit_gitignore is None:
            edit_gitignore = file_path != ".gitignore"

        if edit_gitignore:
            project.add_git_ignore(f"{'!' if committed else ''}{glob_pattern}")
        elif committed is not None and file_path != ".gitignore":
            raise ValueError('"gitignore" is disabled, so it does not make sense to specify "committed"')

        self._changed = None

        if self.readonly:
            project._add_to_manifest(self.path)

    @property
    def marker(self) -> Optional[str]:
        """
        The marker to be added to the file.

        :return: The marker string or None
        """
        if self.project.ejected or not self._should_add_marker:
            return None
        return f"DO NOT EDIT. Generated by pyprojen. To modify, edit .pyprojenrc.py and run 'python .pyprojenrc.py'."

    @abstractmethod
    def synthesize_content(self, resolver: "IResolver") -> Optional[str]:
        """
        Synthesize the content of the file.

        :param resolver: The resolver to use
        :return: The synthesized content or None
        """

    def synthesize(self):
        """
        Synthesize the file.
        """
        outdir = self.project.outdir
        file_path = os.path.join(outdir, self.path)
        resolver = IResolver()
        content = self.synthesize_content(resolver)

        if content is None:
            shutil.rmtree(file_path, ignore_errors=True)
            return

        prev = try_read_file_sync(file_path)
        prev_readonly = not is_writable(file_path)
        if prev is not None and content == prev and prev_readonly == self.readonly:
            print(f"no change in {file_path}")
            self._changed = False
            return

        write_file(file_path, content, options={"readonly": self.readonly, "executable": self.executable})
        self._changed = True

    @property
    def changed(self) -> Optional[bool]:
        """
        Indicates if the file has been changed during synthesis.

        :return: True if changed, False if not, None if not synthesized yet
        """
        return self._changed


class IResolver:
    """
    Interface for resolving values.
    """

    def resolve(self, value: Any, options: Optional[Dict[str, Any]] = None) -> Any:
        """
        Resolve a value.

        :param value: The value to resolve
        :param options: Options for resolution
        :return: The resolved value
        """
        return value


class ResolveOptions:
    """
    Options for resolving values.
    """

    def __init__(self, omit_empty: bool = False, args: Optional[list] = None):
        """
        Initialize ResolveOptions.

        :param omit_empty: Whether to omit empty values
        :param args: Additional arguments
        """
        self.omit_empty = omit_empty
        self.args = args or []


class IResolvable(ABC):
    """
    Interface for resolvable objects.
    """

    @abstractmethod
    def to_json(self) -> Any:
        """
        Convert the object to JSON.

        :return: The JSON representation of the object
        """
